/*
 * MainScreen.java
 *
 * Created on 29 de Agosto de 2008, 10:10
 */

package gui;

import javax.swing.JOptionPane;
import javax.swing.JTextField;
import java.util.Vector;
import bean.Process;
import java.awt.Dimension;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import manager.Calculator;
import thread.AlgorithmStepsThread;

/**
 *
 * @author  Fabricio Reis
 */
public class MainScreen extends javax.swing.JApplet {
    // Definitions shown to the user when the applet starts
    final static String START_TEXT = "Seja bem vindo! \n Para começar a usar este software educativo clique em 'Introdução'.";
    final static int MINIMUM = 1; // This constant defines the minimum burst time allowed to create a process
    final static int MAXIMUM = 10; // This constant defines the maximum burst time allowed to create a process
    
    Vector<Process> readyProcesses = new Vector<Process>(); //This object stores the processes created by the user
    Vector<Process> waitingProcesses = new Vector<Process>(); //This object stores the waiting processes

    int processCounter = 0; //This variable is used to label orderly the blocks in 'jPanelAnimation' (processes in the memory)
    int timeCounter = 0; //This variable is used to implement a logical clock

    Vector<Process> reportBase = new Vector<Process>(); //This vector stores all the processes created with its values (waiting time, turn around).
                                                        //It is used to show a report to the user
    Vector<Process> reportBaseTemp = new Vector<Process>();

    Calculator calculator = new Calculator(); //See the class 'Calculator' for more details
    
    AlgorithmStepsThread st;
    Process newProcess;
    Thread t;

    /** Initializes the applet MainScreen */    
    @Override
    public void init() {
        try {
            this.setSize(1048, 642);
            JOptionPane.showMessageDialog(null, START_TEXT, "", JOptionPane.INFORMATION_MESSAGE);
            java.awt.EventQueue.invokeAndWait(new Runnable() {
                public void run() {
                    initComponents();
                    jPanelLegend.setVisible(false);
                    jPanelProcesses.setVisible(false);
                    jPanelReadyProcesses.setVisible(false);
                    jPanelWaitingProcesses.setVisible(false);
                    jProgressBarExecution.setVisible(false);
                    jLabelTime.setVisible(false);
                    jLabelTimeCounter.setVisible(false);
                }
            });
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }    
    
    /** This method is called from within the init() method to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelIntroduction = new javax.swing.JPanel();
        jScrollPaneIntroduction = new javax.swing.JScrollPane();
        jTextAreaIntroduction = new javax.swing.JTextArea();
        jPanelAlgorithm = new javax.swing.JPanel();
        jScrollPaneAlgorithm = new javax.swing.JScrollPane();
        jTextAreaAlgorithm = new javax.swing.JTextArea();
        jPanelAnimation = new javax.swing.JPanel();
        jPanelCPU = new javax.swing.JPanel();
        jLabelCPU = new javax.swing.JLabel();
        jPanelReadyProcesses = new javax.swing.JPanel();
        jPanelWaitingProcesses = new javax.swing.JPanel();
        jLabelTime = new javax.swing.JLabel();
        jLabelTimeCounter = new javax.swing.JLabel();
        jProgressBarExecution = new javax.swing.JProgressBar();
        jLabelShowBurstTime = new javax.swing.JLabel();
        jLabelShowCreationTime = new javax.swing.JLabel();
        jPanelLegend = new javax.swing.JPanel();
        jTextFieldLegendReady = new javax.swing.JTextField();
        jTextFieldLegendExecuting = new javax.swing.JTextField();
        jTextFieldLegendWaiting = new javax.swing.JTextField();
        jTextFieldLegendI = new javax.swing.JTextField();
        jTextFieldLegendJ = new javax.swing.JTextField();
        jPanelProcesses = new javax.swing.JPanel();
        jLabelBurstTime = new javax.swing.JLabel();
        jTextFieldBurstTime = new javax.swing.JTextField();
        jButtonCreateProcess = new javax.swing.JButton();
        jButtonIntroduction = new javax.swing.JButton();
        jButtonStart = new javax.swing.JButton();
        jButtonAlgorithmSteps = new javax.swing.JButton();
        jButtonRestart = new javax.swing.JButton();
        jButtonReport = new javax.swing.JButton();

        setBackground(new java.awt.Color(204, 204, 204));

        jPanelIntroduction.setBorder(javax.swing.BorderFactory.createTitledBorder("Introdução"));

        jTextAreaIntroduction.setColumns(20);
        jTextAreaIntroduction.setEditable(false);
        jTextAreaIntroduction.setFont(new java.awt.Font("Tahoma", 1, 12));
        jTextAreaIntroduction.setRows(5);
        jTextAreaIntroduction.setToolTipText("Aqui será exibida uma breve introdução da política tratada");
        jScrollPaneIntroduction.setViewportView(jTextAreaIntroduction);

        javax.swing.GroupLayout jPanelIntroductionLayout = new javax.swing.GroupLayout(jPanelIntroduction);
        jPanelIntroduction.setLayout(jPanelIntroductionLayout);
        jPanelIntroductionLayout.setHorizontalGroup(
            jPanelIntroductionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPaneIntroduction, javax.swing.GroupLayout.DEFAULT_SIZE, 1012, Short.MAX_VALUE)
        );
        jPanelIntroductionLayout.setVerticalGroup(
            jPanelIntroductionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPaneIntroduction, javax.swing.GroupLayout.DEFAULT_SIZE, 87, Short.MAX_VALUE)
        );

        jPanelAlgorithm.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Algoritmo", javax.swing.border.TitledBorder.LEFT, javax.swing.border.TitledBorder.TOP));

        jTextAreaAlgorithm.setColumns(20);
        jTextAreaAlgorithm.setEditable(false);
        jTextAreaAlgorithm.setFont(new java.awt.Font("Tahoma", 1, 12));
        jTextAreaAlgorithm.setRows(5);
        jTextAreaAlgorithm.setToolTipText("Aqui será exibido o algoritmo da política tratada");
        jScrollPaneAlgorithm.setViewportView(jTextAreaAlgorithm);

        javax.swing.GroupLayout jPanelAlgorithmLayout = new javax.swing.GroupLayout(jPanelAlgorithm);
        jPanelAlgorithm.setLayout(jPanelAlgorithmLayout);
        jPanelAlgorithmLayout.setHorizontalGroup(
            jPanelAlgorithmLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPaneAlgorithm, javax.swing.GroupLayout.DEFAULT_SIZE, 405, Short.MAX_VALUE)
        );
        jPanelAlgorithmLayout.setVerticalGroup(
            jPanelAlgorithmLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPaneAlgorithm, javax.swing.GroupLayout.DEFAULT_SIZE, 438, Short.MAX_VALUE)
        );

        jPanelAnimation.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Gerência de Processos", javax.swing.border.TitledBorder.LEFT, javax.swing.border.TitledBorder.TOP));
        jPanelAnimation.setToolTipText("Aqui serão exibidas animações gráficas da gerência de processos");
        jPanelAnimation.setPreferredSize(new java.awt.Dimension(474, 204));

        jPanelCPU.setBackground(new java.awt.Color(200, 233, 251));
        jPanelCPU.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
        jPanelCPU.setToolTipText("UCP (Unidade Central de Processamento)");
        jPanelCPU.setPreferredSize(new java.awt.Dimension(98, 69));

        jLabelCPU.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabelCPU.setText("UCP");

        javax.swing.GroupLayout jPanelCPULayout = new javax.swing.GroupLayout(jPanelCPU);
        jPanelCPU.setLayout(jPanelCPULayout);
        jPanelCPULayout.setHorizontalGroup(
            jPanelCPULayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelCPULayout.createSequentialGroup()
                .addContainerGap(72, Short.MAX_VALUE)
                .addComponent(jLabelCPU))
        );
        jPanelCPULayout.setVerticalGroup(
            jPanelCPULayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelCPULayout.createSequentialGroup()
                .addContainerGap(52, Short.MAX_VALUE)
                .addComponent(jLabelCPU))
        );

        jPanelReadyProcesses.setBorder(javax.swing.BorderFactory.createTitledBorder("Processos Prontos"));
        jPanelReadyProcesses.setToolTipText("Processos Prontos");
        jPanelReadyProcesses.setPreferredSize(new java.awt.Dimension(332, 86));

        javax.swing.GroupLayout jPanelReadyProcessesLayout = new javax.swing.GroupLayout(jPanelReadyProcesses);
        jPanelReadyProcesses.setLayout(jPanelReadyProcessesLayout);
        jPanelReadyProcessesLayout.setHorizontalGroup(
            jPanelReadyProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 316, Short.MAX_VALUE)
        );
        jPanelReadyProcessesLayout.setVerticalGroup(
            jPanelReadyProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 56, Short.MAX_VALUE)
        );

        jPanelWaitingProcesses.setBorder(javax.swing.BorderFactory.createTitledBorder("Processos em Espera"));
        jPanelWaitingProcesses.setToolTipText("Processos em espera");
        jPanelWaitingProcesses.setPreferredSize(new java.awt.Dimension(332, 88));

        javax.swing.GroupLayout jPanelWaitingProcessesLayout = new javax.swing.GroupLayout(jPanelWaitingProcesses);
        jPanelWaitingProcesses.setLayout(jPanelWaitingProcessesLayout);
        jPanelWaitingProcessesLayout.setHorizontalGroup(
            jPanelWaitingProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 316, Short.MAX_VALUE)
        );
        jPanelWaitingProcessesLayout.setVerticalGroup(
            jPanelWaitingProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 58, Short.MAX_VALUE)
        );

        jLabelTime.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabelTime.setText("Tempo:");
        jLabelTime.setToolTipText("Relógio lógico do tempo de processamento");

        jLabelTimeCounter.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabelTimeCounter.setText("0");
        jLabelTimeCounter.setToolTipText("Relógio lógico do tempo de processamento");

        jProgressBarExecution.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jProgressBarExecution.setStringPainted(true);

        jLabelShowBurstTime.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabelShowBurstTime.setText(" ");

        jLabelShowCreationTime.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabelShowCreationTime.setText(" ");

        javax.swing.GroupLayout jPanelAnimationLayout = new javax.swing.GroupLayout(jPanelAnimation);
        jPanelAnimation.setLayout(jPanelAnimationLayout);
        jPanelAnimationLayout.setHorizontalGroup(
            jPanelAnimationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelAnimationLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelAnimationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelAnimationLayout.createSequentialGroup()
                        .addGap(23, 23, 23)
                        .addComponent(jPanelCPU, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanelAnimationLayout.createSequentialGroup()
                        .addGap(40, 40, 40)
                        .addComponent(jLabelTime)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelTimeCounter))
                    .addGroup(jPanelAnimationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(jLabelShowBurstTime, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabelShowCreationTime, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jProgressBarExecution, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 93, Short.MAX_VALUE)
                .addGroup(jPanelAnimationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jPanelReadyProcesses, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanelWaitingProcesses, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        jPanelAnimationLayout.setVerticalGroup(
            jPanelAnimationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelAnimationLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelAnimationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelAnimationLayout.createSequentialGroup()
                        .addComponent(jPanelReadyProcesses, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelWaitingProcesses, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanelAnimationLayout.createSequentialGroup()
                        .addGroup(jPanelAnimationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabelTime)
                            .addComponent(jLabelTimeCounter))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelCPU, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jProgressBarExecution, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelShowBurstTime)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelShowCreationTime)))
                .addContainerGap())
        );

        jPanelLegend.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Legenda", javax.swing.border.TitledBorder.LEFT, javax.swing.border.TitledBorder.TOP));
        jPanelLegend.setToolTipText("Legendas");

        jTextFieldLegendReady.setBackground(new java.awt.Color(255, 255, 255));
        jTextFieldLegendReady.setEditable(false);
        jTextFieldLegendReady.setFont(new java.awt.Font("Tahoma", 1, 11));
        jTextFieldLegendReady.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jTextFieldLegendReady.setText("PRONTO");

        jTextFieldLegendExecuting.setBackground(new java.awt.Color(255, 51, 0));
        jTextFieldLegendExecuting.setEditable(false);
        jTextFieldLegendExecuting.setFont(new java.awt.Font("Tahoma", 1, 11));
        jTextFieldLegendExecuting.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jTextFieldLegendExecuting.setText("EXECUTANDO");

        jTextFieldLegendWaiting.setBackground(new java.awt.Color(51, 255, 255));
        jTextFieldLegendWaiting.setEditable(false);
        jTextFieldLegendWaiting.setFont(new java.awt.Font("Tahoma", 1, 11));
        jTextFieldLegendWaiting.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jTextFieldLegendWaiting.setText("ESPERANDO");

        jTextFieldLegendI.setBackground(new java.awt.Color(0, 255, 0));
        jTextFieldLegendI.setFont(new java.awt.Font("Tahoma", 1, 12));
        jTextFieldLegendI.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jTextFieldLegendI.setText("\"i\"");

        jTextFieldLegendJ.setBackground(new java.awt.Color(255, 255, 102));
        jTextFieldLegendJ.setFont(new java.awt.Font("Tahoma", 1, 12));
        jTextFieldLegendJ.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jTextFieldLegendJ.setText("\"j\"");

        javax.swing.GroupLayout jPanelLegendLayout = new javax.swing.GroupLayout(jPanelLegend);
        jPanelLegend.setLayout(jPanelLegendLayout);
        jPanelLegendLayout.setHorizontalGroup(
            jPanelLegendLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelLegendLayout.createSequentialGroup()
                .addGap(127, 127, 127)
                .addComponent(jTextFieldLegendReady, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldLegendExecuting, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldLegendWaiting, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldLegendI, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldLegendJ, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(132, Short.MAX_VALUE))
        );
        jPanelLegendLayout.setVerticalGroup(
            jPanelLegendLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelLegendLayout.createSequentialGroup()
                .addGroup(jPanelLegendLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldLegendJ, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldLegendI, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldLegendExecuting, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldLegendReady, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldLegendWaiting, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanelProcesses.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Processos", javax.swing.border.TitledBorder.LEFT, javax.swing.border.TitledBorder.TOP));
        jPanelProcesses.setToolTipText("Painel para criar processos");

        jLabelBurstTime.setText("Tempo de Burst:");

        jTextFieldBurstTime.setToolTipText("Digite aqui o tempo de burst do processo a ser criado");

        jButtonCreateProcess.setText("Criar");
        jButtonCreateProcess.setToolTipText("Clique aqui para criar um processo");
        jButtonCreateProcess.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCreateProcessActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelProcessesLayout = new javax.swing.GroupLayout(jPanelProcesses);
        jPanelProcesses.setLayout(jPanelProcessesLayout);
        jPanelProcessesLayout.setHorizontalGroup(
            jPanelProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelProcessesLayout.createSequentialGroup()
                .addGap(85, 85, 85)
                .addComponent(jLabelBurstTime)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldBurstTime, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(32, 32, 32)
                .addComponent(jButtonCreateProcess)
                .addContainerGap(302, Short.MAX_VALUE))
        );
        jPanelProcessesLayout.setVerticalGroup(
            jPanelProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelProcessesLayout.createSequentialGroup()
                .addGroup(jPanelProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelProcessesLayout.createSequentialGroup()
                        .addGap(3, 3, 3)
                        .addGroup(jPanelProcessesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextFieldBurstTime, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabelBurstTime)))
                    .addComponent(jButtonCreateProcess))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jButtonIntroduction.setToolTipText("Clique aqui para ver o algoritmo e um resumo teórico da política tratada");
        jButtonIntroduction.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonIntroduction.setLabel("Introdução");
        jButtonIntroduction.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonIntroductionActionPerformed(evt);
            }
        });

        jButtonStart.setText("Iniciar");
        jButtonStart.setToolTipText("Clique aqui para criar processos");
        jButtonStart.setEnabled(false);
        jButtonStart.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonStartActionPerformed(evt);
            }
        });

        jButtonAlgorithmSteps.setText("Passos do Algoritmo");
        jButtonAlgorithmSteps.setToolTipText("Clique aqui para escalonar e executar um processo da lista");
        jButtonAlgorithmSteps.setEnabled(false);
        jButtonAlgorithmSteps.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonAlgorithmSteps.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAlgorithmStepsActionPerformed(evt);
            }
        });

        jButtonRestart.setText("Reiniciar");
        jButtonRestart.setToolTipText("Clique aqui para reiniciar o software");
        jButtonRestart.setEnabled(false);
        jButtonRestart.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonRestart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRestartActionPerformed(evt);
            }
        });

        jButtonReport.setText("Relatório");
        jButtonReport.setToolTipText("Clique aqui para exibir o relatório de execução");
        jButtonReport.setEnabled(false);
        jButtonReport.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonReport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonReportActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jPanelIntroduction, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jPanelAlgorithm, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(jPanelAnimation, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 601, Short.MAX_VALUE)
                                    .addComponent(jPanelLegend, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jPanelProcesses, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(291, 291, 291)
                        .addComponent(jButtonIntroduction)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonStart)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonAlgorithmSteps)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonReport)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonRestart)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanelIntroduction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanelAlgorithm, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanelAnimation, javax.swing.GroupLayout.PREFERRED_SIZE, 232, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelLegend, javax.swing.GroupLayout.PREFERRED_SIZE, 56, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanelProcesses, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonIntroduction)
                    .addComponent(jButtonStart)
                    .addComponent(jButtonAlgorithmSteps)
                    .addComponent(jButtonReport)
                    .addComponent(jButtonRestart))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonIntroductionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonIntroductionActionPerformed
        final String TEXT_BASE_INTRODUCTION = "\n" +
                                              "Informalmente, processo pode ser visto como um programa em execução, porém esta é uma idéia incompleta de como o sistema operacional\n" +
                                              "o trata. Atualmente, os computadores são capazes de realizar várias tarefas ao mesmo tempo. Ou seja, equanto executa um programa, um\n" +
                                              "computador pode, por exemplo, executar operações de leitura/escrita no disco ou executar outro programa. Em sistemas monoprocessados,\n" +
                                              "as tarefas não são executadas ao mesmo tempo, existe apenas a impressão delas estarem sendo executadas ao mesmo tempo, pois o processador\n" +
                                              "é capaz de realizar um tarefa por vez. Nesse sentido, existe o conceito de multiprogramação, que é a capacidade de armazenar o código de\n" +
                                              "muitos processos (programas) na memória simultaneamente para que eles possam ser executados. Assim, os programas podem acessar os recursos\n" +
                                              "do computador e serem executados em um tempo razoável tendo a sensação de multiprocessamento.\n\n" +
                                              "Nesse contexto, basicamente o gerenciador de processos garante que cada processo receba uma fatia de tempo suficiente para funcionar\n" +
                                              "corretamente e escalona (de acordo com a política implementada) os processos presentes na fila de prontos para que eles sejam executados.\n" +
                                              "A tarefa dessas políticas é escolher qual dos processos presentes na fila de prontos será o próximo a ser executado.\n" +
                                              "Utiliza-se como critério básico o objetivo de aumentar ao máximo o rendimento do sistema operacional, diminuido o tempo de resposta\n" +
                                              "(turnaround time = intervalo de tempo da submissão de um processo até o seu termino) ao usuário. Para conseguir um aumento de eficiência\n" +
                                              "no processador, busca-se reduzir o tempo médio de espera na fila de processos prontos. Tempo de espera é a soma dos períodos gastos por\n" +
                                              "um processo aguardando na fila de espera.\n\n" +
                                              "Existem duas categorias principais de políticas de escalonamento: preemptiva e não-preemptiva. Nas políticas não-preemptivas, quando um\n" +
                                              "processo assume o controle do processador, ele o mantém até terminar. Sua principal vantagem em relação às políticas preemptivas, é a\n" +
                                              "simplicidade. Sua desvantagem é a falta de resposta ao comportamento do sistema quando, por exemplo, um processo com alto tempo de\n" +
                                              "processamento detém controle do processador, todos os demais têm de esperar.\n" +
                                              "Nas políticas preemptivas, depois de certo tempo (devido, por exemplo, às diferentes prioridades dos processos), o sistema operacional\n" +
                                              "pode retomar o controle do processador.\n\n" +
                                              "*Este software educativo trata da política SRTF (Shortest Remaining Time First - o menor tempo restante primeiro).\n" +
                                              "Também conhecida como SRTN (Shortest Remaining Time Next), esta política diferencia-se da política SJF (Shortest Job First) quanto à\n" +
                                              "preempção. Ou seja, nesta política, um processo pode perder o controle do processador para outro processo que tenha tempo de execução\n" +
                                              "menor que o seu restante.\n\n" +
                                              "* VEJA O ALGORITMO ABAIXO";
        final String TEXT_BASE_ALGORITHM = "funcao srtf (referência de vetor<TAD_Processo> listaDeProntos, referência de vetor<TAD_Processo> listaDeEspera,\n" +
                                           "                 TAD_Processo processoNovo, inteiro tamanhoMaximo) : TAD_Processo\n" +
                                           "inicio\n" +
                                           "    TAD_Processo processo;\n" +
                                           "    inteiro aux := tamanhoMaximo;\n\n" +
                                           
                                           "    se (processoNovo <> null)\n" +
                                           "        srtf := processoNovo;\n" +
                                           "    Fim se\n" +
                                           "    senão\n" +
                                           "        se (listaDeEspera não está vazia)\n" +
                                           "            processo := listaDeEspera.último elemento;\n" +
                                           "            srtf := processo;\n" +
                                           "            remove elemento igual a 'processo' do vetor listaDeEspera;\n" +
                                           "        Fim se\n" +
                                           "        senão\n" +
                                           "            se (listaDeProntos não está vazia)\n" +
                                           "                para (inteiro i := 0; i <= (tamanho de listaDeProntos - 1); i++)\n" +
                                           "                    se (aux > listaDeProntos.elemento(i).tempoDeVida)\n" +
                                           "                        aux := listaDeProntos.elemento(i).tempoDeVida);\n" +
                                           "                        processo := listaDeProntos.elemento(i);\n" +
                                           "                        se (aux = 1)\n" +
                                           "                            i := tamanho de 'listaDeProntos';\n" +
                                           "                        Fim se\n" +
                                           "                    Fim se\n" +
                                           "                Fim para\n" +
                                           "                srtf := processo;\n" +
                                           "                remove elemento igual a 'processo' do vetor listaDeProntos;\n" +
                                           "            Fim se\n" +
                                           "            senão\n" +
                                           "                Exibir mensagem \"Lista de processos prontos vazia!\";\n" +
                                           "                srtf := null;\n" +
                                           "            Fim senão\n" +
                                           "        Fim senão\n" +
                                           "    Fim senão\n" +
                                           "fim.\n\n" +

                                           "procedimento criarProcesso (referência de vetor<TAD_Processo> listaDeProntos, referência de vetor<TAD_Processo> listaDeEspera,\n" +
                                           "                                TAD_Processo processoNovo)\n" +
                                           "inicio\n\n" +
                                           "    se ('função srtf' estiver sendo executada)\n" +
                                           "        se (processoNovo.tempoDeVida < srtf.processo.tempoDeVida)\n" +
                                           "            para a execução da 'função srtf';\n" +
                                           "            adiciona 'srtf.processo' no fim da lista 'listaDeEspera';\n" +
                                           "            srtf(listaDeProntos, listaDeEspera, processoNovo, tamanhoMaximo);\n" +
                                           "        Fim se\n" +
                                           "        senão\n" +
                                           "            adiciona processoNovo no fim da lista 'listaDeProntos';\n" +
                                           "        Fim senão\n" +
                                           "    Fim se\n" +
                                           "    senão\n" +
                                           "        adiciona processoNovo no fim da lista 'listaDeProntos';\n" +
                                           "    Fim senão\n" +
                                           "fim.";

        this.jTextAreaIntroduction.setText(TEXT_BASE_INTRODUCTION);
        this.jTextAreaAlgorithm.setText(TEXT_BASE_ALGORITHM);
        JOptionPane.showMessageDialog(null, "Após conferir o texto de introdução e o algoritmo tratado, \n" +
                "clique em 'Iniciar' para criar processos. \n", "DICA", JOptionPane.INFORMATION_MESSAGE);
        this.jButtonIntroduction.setEnabled(false);
        this.jButtonStart.setEnabled(true);
        this.jTextAreaIntroduction.setToolTipText("Introdução da política tratada");
        this.jTextAreaAlgorithm.setToolTipText("Algoritmo da política tratada");
    }//GEN-LAST:event_jButtonIntroductionActionPerformed

    private void jButtonStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonStartActionPerformed
        this.jPanelLegend.setVisible(true);
        this.jPanelProcesses.setVisible(true);
        this.jPanelReadyProcesses.setVisible(true);
        this.jPanelWaitingProcesses.setVisible(true);
        this.jLabelTimeCounter.setText("0");
        this.jLabelTime.setVisible(true);
        this.jLabelTimeCounter.setVisible(true);
        this.jPanelAnimation.setToolTipText("Aqui são exibidas animações gráficas da gerência de processador");
        JOptionPane.showMessageDialog(null, "Para criar um processo, digite seu tempo de burst e clique em 'Criar'.\n" +
                "OBSERVAÇÕES: 1) São permitidos somente valores inteiros entre " + MINIMUM + " e " + MAXIMUM + ";\n" +
                "                                2) Os processos criados vão para a lista de processos prontos;\n" +
                "                                3) Para escalonar e executar um processo, clique em 'Passos do Algoritmo';\n" +
                "                                4) Passe o cursor do mouse sobre os processos criados (Blocos Brancos)\n" +
                "                                     ou em espera (Blocos Azuis) para ver seus tempos de burst e de chegada.", "DICA", JOptionPane.INFORMATION_MESSAGE);
        this.jButtonStart.setEnabled(false);
        this.jButtonRestart.setEnabled(true);
    }//GEN-LAST:event_jButtonStartActionPerformed

    private void jButtonCreateProcessActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCreateProcessActionPerformed
        if( (this.jTextFieldBurstTime.getText().equals("")) || ((Integer.parseInt(this.jTextFieldBurstTime.getText()) < MINIMUM)) || ((Integer.parseInt(this.jTextFieldBurstTime.getText()) > MAXIMUM)) ){
            JOptionPane.showMessageDialog(null, "Digite um número inteiro entre " + MINIMUM + " e " + MAXIMUM + " para o tempo de burst do processo.", "ERRO", JOptionPane.ERROR_MESSAGE);
        }
        else{
            if(this.readyProcesses == null) {
                this.readyProcesses = new Vector<Process>();
                this.reportBaseTemp = new Vector<Process>();
            }
            if(this.readyProcesses.size() <= 8) {
                Process process = new Process();
                process.setLifeTime(Integer.parseInt(this.jTextFieldBurstTime.getText()));
                process.setId(this.processCounter);
                process.setState(0);
                
                if(this.st != null) {
                    this.timeCounter = this.st.getTimeCounter();
                    process.setCreationTime(this.timeCounter);

                    if ((this.st.getJDialogNextStep().isVisible() == true) && (this.st.getJProgressBarExecution().isVisible() != true)) {
                        this.readyProcesses.add(process);
                        this.reportBaseTemp.add(process);
                        this.paintReadyProcesses(this.readyProcesses);
                        this.processCounter++;

                        if (this.st.getBlock() != null) {
                            this.jPanelReadyProcesses.add(this.st.getBlock());
                        }

                        if (this.st.getBlock1() != null) {
                            this.jPanelReadyProcesses.add(this.st.getBlock1());
                        }

                        if (this.st.getBlock2() != null) {
                            this.jPanelReadyProcesses.add(this.st.getBlock2());
                        }
                        
                        if (this.st.getBlock3() != null) {
                            this.jPanelReadyProcesses.add(this.st.getBlock3());
                        }

                        JOptionPane.showMessageDialog(null, "Processo criado com sucesso!\n" +
                                "DICAS: 1) Para escalonar e executar um processo da lista, clique em 'Passos do Algoritmo';\n" +
                                "              2) Após a execução de um processo, clique em 'Relatório' para exibir informações estatísticas. ", "DICA", JOptionPane.INFORMATION_MESSAGE);
                    }
                    else {
                        if (this.st.getJProgressBarExecution().isVisible() == true) {
                            if (process.getLifeTime() < this.st.getRemainingTimeToFinishRunning()) {
                                Process processAux = new Process();
                                if (this.st.getNewProcess() != null) {
                                    processAux = this.st.getNewProcess();
                                }
                                else {
                                    processAux = this.st.getProcess();
                                }
                                JOptionPane.showMessageDialog(null, "Processo criado com sucesso!\n" +
                                        "OBSERVAÇÕES: 1) o processo criado (P" + process.getId() +  ") possui tempo de vida MENOR que o tempo de vida restante do processo escalonado (P" + processAux.getId() + ");\n" +
                                        "                                2) o processo escalonado (P" + processAux.getId() + ") será interrompido e entrará na lista de processos em espera (Blocos Azuis);\n" +
                                        "                                3) o processo criado (P" + process.getId() +  ") começará a ser executado imediatamente.", "ATENÇÃO", JOptionPane.WARNING_MESSAGE);

                                processAux.setLifeTime(this.st.getRemainingTimeToFinishRunning());
                                processAux.setTimeWhenIncludeInWaitingState(this.timeCounter);
                                this.waitingProcesses.add(processAux);
                                this.paintWaitingProcesses(this.waitingProcesses);
                                this.processCounter++;
                                
                                this.newProcess = new Process();
                                this.newProcess = process;

                                t.stop();
                                
                                this.st.getJDialogNextStep().setVisible(false);
                                this.st.setJDialogNextStep(null);
                                this.st = null;

                                this.jButtonAlgorithmStepsActionPerformed(evt);
                            }
                            else {
                                this.readyProcesses.add(process);
                                this.reportBaseTemp.add(process);
                                this.paintReadyProcesses(this.readyProcesses);
                                this.processCounter++;
                                JOptionPane.showMessageDialog(null, "Processo criado com sucesso!\n" +
                                        "DICAS: 1) Para escalonar e executar um processo da lista, clique em 'Passos do Algoritmo';\n" +
                                        "              2) Após a execução de um processo, clique em 'Relatório' para exibir informações estatísticas. ", "DICA", JOptionPane.INFORMATION_MESSAGE);
                            }
                        }
                        else {
                            this.readyProcesses.add(process);
                            this.reportBaseTemp.add(process);
                            this.paintReadyProcesses(this.readyProcesses);
                            this.processCounter++;
                            JOptionPane.showMessageDialog(null, "Processo criado com sucesso!\n" +
                                    "DICAS: 1) Para escalonar e executar um processo da lista, clique em 'Passos do Algoritmo';\n" +
                                    "              2) Após a execução de um processo, clique em 'Relatório' para exibir informações estatísticas. ", "DICA", JOptionPane.INFORMATION_MESSAGE);
                        }
                    }
                }
                else {
                    process.setCreationTime(this.timeCounter);
                    this.readyProcesses.add(process);
                    this.reportBaseTemp.add(process);
                    this.paintReadyProcesses(this.readyProcesses);
                    this.processCounter++;
                    JOptionPane.showMessageDialog(null, "Processo criado com sucesso!\n" +
                            "DICAS: 1) Para escalonar e executar um processo da lista de prontos, clique em 'Passos do Algoritmo';\n" +
                            "              2) Após a execução de um processo, clique em 'Relatório' para exibir informações estatísticas. ", "DICA", JOptionPane.INFORMATION_MESSAGE);
                }
                
                if(this.st != null) {
                    if(!this.st.getJDialogNextStep().isVisible()) {
                        this.jButtonAlgorithmSteps.setEnabled(true);
                    }    
                }
                else {
                    this.jButtonAlgorithmSteps.setEnabled(true);
                }
            }
            else {
                JOptionPane.showMessageDialog(null, "A lista de processos prontos está cheia. \n" +
                            "DICA: Clique em 'Passos do Algoritmo' para escalonar e executar um processo da lista.", "ATENÇÃO", JOptionPane.WARNING_MESSAGE);
            }
        }
        this.jTextFieldBurstTime.setText("");
}//GEN-LAST:event_jButtonCreateProcessActionPerformed

    private void jButtonAlgorithmStepsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAlgorithmStepsActionPerformed
        if(this.st != null) {
            this.reportBase = this.st.getReportBase();
            this.timeCounter = this.st.getTimeCounter();
            this.newProcess = this.st.getNewProcess();
        }
        this.jProgressBarExecution.setValue(0);
        this.st = new AlgorithmStepsThread(this, this.jButtonAlgorithmSteps, this.jButtonReport, this.readyProcesses, this.waitingProcesses,
                                      this.reportBase, this.timeCounter, this.jPanelCPU, this.jPanelReadyProcesses, this.jProgressBarExecution,
                                      this.jLabelShowBurstTime, this.jLabelShowCreationTime, this.jLabelTimeCounter, this.jLabelCPU,
                                      MAXIMUM, this.newProcess);
        t = new Thread(this.st);
        t.start();
}//GEN-LAST:event_jButtonAlgorithmStepsActionPerformed

    private void jButtonRestartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRestartActionPerformed
        this.jTextFieldBurstTime.setText("");
        this.timeCounter = 0;
        this.processCounter = 0;
        this.jLabelTime.setVisible(false);
        this.jLabelTimeCounter.setVisible(false);
        this.jProgressBarExecution.setVisible(false);
        this.jLabelShowBurstTime.setVisible(false);
        this.jLabelShowCreationTime.setVisible(false);
        this.jPanelReadyProcesses.removeAll();
        this.jPanelReadyProcesses.repaint();
        this.jPanelReadyProcesses.setVisible(false);
        this.jPanelWaitingProcesses.removeAll();
        this.jPanelWaitingProcesses.repaint();
        this.jPanelWaitingProcesses.setVisible(false);
        this.jPanelCPU.removeAll();
        this.jPanelCPU.repaint();
        this.jPanelCPU.add(this.jLabelCPU);
        this.jPanelProcesses.setVisible(false);
        this.jPanelLegend.setVisible(false);
        this.jButtonStart.setEnabled(true);
        this.jButtonAlgorithmSteps.setEnabled(false);
        this.jButtonReport.setEnabled(false);
        this.jButtonRestart.setEnabled(false);
        this.readyProcesses = null;
        this.reportBase = null;
        this.reportBaseTemp = null;
        if(this.st != null) {
            this.st.getJDialogNextStep().setVisible(false);
            this.st.setJDialogNextStep(null);
            this.st = null;
        }
        t.stop();
        System.gc();
    }//GEN-LAST:event_jButtonRestartActionPerformed

    private void jButtonReportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonReportActionPerformed
        String report = "";
        report += "\n* Informações sobre os processos criados\n";

        if(this.st != null) {
            this.reportBase = this.st.getReportBase();
        }
        
        for(int i = 0; i <= (this.reportBaseTemp.size() - 1); i++) {
            report += "P" + this.reportBaseTemp.elementAt(i).getId() + ": tempo de burst = " + this.reportBaseTemp.elementAt(i).getLifeTime() + ";  tempo na criação = " + this.reportBaseTemp.elementAt(i).getCreationTime() + ";\n";
        }
        
        report += "* OBS.: os processos abaixo são listados na ordem em que foram executados!\n\n";
        report += "\n* Tempos de espera\n";
        
        for(int i = 0; i <= (this.reportBase.size() - 1); i++) {
            report += "P" + this.reportBase.elementAt(i).getId() + " = " + this.reportBase.elementAt(i).getWaitingTime() + ";  ";
            if ((i >0) && (i % 10 == 0)) {
                report += "\n";
            }
        }

        int mediumWaintingTime = calculator.averageWaitingTime(this.reportBase);
        report += "\n\n* Tempo médio de espera\n";
        report += "(";
        for(int i = 0; i <= (this.reportBase.size() - 2); i++) {
            report += this.reportBase.elementAt(i).getWaitingTime() + " + ";
            if((i >0) && (i % 21 == 0)) {
                report += "\n";
            }
        }
        report += this.reportBase.lastElement().getWaitingTime() + ") / " + this.reportBase.size() + " = " + mediumWaintingTime;
        
        report += "\n\n* Tempos de retorno (turn around)\n";
        
        for(int i = 0; i <= (this.reportBase.size() - 1); i++) {
            report += "P" + this.reportBase.elementAt(i).getId() + " = " + this.reportBase.elementAt(i).getTurnAround() + ";  ";
            if ((i >0) && (i % 10 == 0)) {
                report += "\n";
            }
        }
        
        int mediumTurnAround = calculator.averageTurnAround(this.reportBase);
        report += "\n\n* Tempo médio de retorno (turn around médio)\n";
        report += "(";
        for(int i = 0; i <= (this.reportBase.size() - 2); i++) {
            report += this.reportBase.elementAt(i).getTurnAround() + " + ";
            if((i >0) && (i % 21 == 0)) {
                report += "\n";
            }
        }
        report += this.reportBase.lastElement().getTurnAround() + ") / " + this.reportBase.size() + " = " + mediumTurnAround;
        
        JTextArea reportArea = new JTextArea(report);
        reportArea.setEditable(false);
        JScrollPane scroll = new JScrollPane(reportArea);
        Dimension preferredSize = new Dimension();
        preferredSize.setSize(625, 428);
        scroll.setPreferredSize(preferredSize);
        
        if(!this.readyProcesses.isEmpty()) {
            JOptionPane.showMessageDialog(null, scroll, "RELATÓRIO PARCIAL", JOptionPane.INFORMATION_MESSAGE);
        }
        else {
            JOptionPane.showMessageDialog(null, scroll, "RELATÓRIO FINAL", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_jButtonReportActionPerformed
    
    /*
     * This method paints the blocks of ready processes in 'jPanelReadyProcesses'.
     */ 
    public void paintReadyProcesses(Vector<Process> processesQueue) {
        int orientationAxisYSecMem = 50;
        
        this.jPanelReadyProcesses.removeAll();
        this.jPanelReadyProcesses.repaint();
        
        for(int i = 0; i <= (processesQueue.size() - 1); i++) {
            JTextField block = new JTextField();
            block.setBackground(new java.awt.Color(255, 255, 255));
            block.setForeground(new java.awt.Color(0, 0, 0));
            block.setHorizontalAlignment(javax.swing.JTextField.CENTER);
            block.setEditable(false);
            block.setText("P" + String.valueOf(processesQueue.elementAt(i).getId()));
            block.setToolTipText("Tempo de burst = " + String.valueOf(processesQueue.elementAt(i).getLifeTime()) + ";\n  Tempo na criação = " + String.valueOf(processesQueue.elementAt(i).getCreationTime()));
            this.jPanelReadyProcesses.add(block);
            if (i <= 8) {
                block.setBounds(10+(i*35), orientationAxisYSecMem, 30, 30);
            }
        }
    }
    
    /*
     * This method paints the blocks of waiting processes in 'JPanelWaitingProcesses'
     */ 
    public void paintWaitingProcesses(Vector<Process> processes) {
        int orientationAxisYSecMem = 50;
        
        this.jPanelWaitingProcesses.removeAll();
        this.jPanelWaitingProcesses.repaint();
        
        for(int i = 0; i <= (processes.size() - 1); i++) {
            JTextField block = new JTextField();
            block.setBackground(new java.awt.Color(51, 255, 255));
            block.setForeground(new java.awt.Color(0, 0, 0));
            block.setHorizontalAlignment(javax.swing.JTextField.CENTER);
            block.setEditable(false);
            block.setText("P" + String.valueOf(processes.elementAt(i).getId()));
            block.setToolTipText("Tempo de burst restante = " + String.valueOf(processes.elementAt(i).getLifeTime()));
            this.jPanelWaitingProcesses.add(block);
            if (i <= 8) {
                block.setBounds(10+(i*35), orientationAxisYSecMem, 30, 30);
            }
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonAlgorithmSteps;
    private javax.swing.JButton jButtonCreateProcess;
    private javax.swing.JButton jButtonIntroduction;
    private javax.swing.JButton jButtonReport;
    private javax.swing.JButton jButtonRestart;
    private javax.swing.JButton jButtonStart;
    private javax.swing.JLabel jLabelBurstTime;
    private javax.swing.JLabel jLabelCPU;
    private javax.swing.JLabel jLabelShowBurstTime;
    private javax.swing.JLabel jLabelShowCreationTime;
    private javax.swing.JLabel jLabelTime;
    private javax.swing.JLabel jLabelTimeCounter;
    private javax.swing.JPanel jPanelAlgorithm;
    private javax.swing.JPanel jPanelAnimation;
    private javax.swing.JPanel jPanelCPU;
    private javax.swing.JPanel jPanelIntroduction;
    private javax.swing.JPanel jPanelLegend;
    private javax.swing.JPanel jPanelProcesses;
    private javax.swing.JPanel jPanelReadyProcesses;
    private javax.swing.JPanel jPanelWaitingProcesses;
    private javax.swing.JProgressBar jProgressBarExecution;
    private javax.swing.JScrollPane jScrollPaneAlgorithm;
    private javax.swing.JScrollPane jScrollPaneIntroduction;
    private javax.swing.JTextArea jTextAreaAlgorithm;
    private javax.swing.JTextArea jTextAreaIntroduction;
    private javax.swing.JTextField jTextFieldBurstTime;
    private javax.swing.JTextField jTextFieldLegendExecuting;
    private javax.swing.JTextField jTextFieldLegendI;
    private javax.swing.JTextField jTextFieldLegendJ;
    private javax.swing.JTextField jTextFieldLegendReady;
    private javax.swing.JTextField jTextFieldLegendWaiting;
    // End of variables declaration//GEN-END:variables
    
}
